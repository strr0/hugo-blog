---
title: "接口与抽象类"
date: 2023-04-06T15:30:00+08:00
categories: ["development"]
tags: ["java"]
draft: false
---

### 抽象类和接口的对比

|**参数**|**抽象类**|**接口**|
|----------|----------|----------|
|默认的方法实现|它可以有默认的方法实现|接口完全是抽象的。它根本不存在方法的实现|
|实现|子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。|子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现|
|构造器|抽象类可以有构造器|接口不能有构造器|
|与正常Java类的区别|除了你不能实例化抽象类之外，它和普通Java类没有任何区别|接口是完全不同的类型|
|访问修饰符|抽象方法可以有**public**、**protected**和**default**这些修饰符 |接口方法默认修饰符是**public**。你不可以使用其它修饰符。|
|main方法|抽象方法可以有main方法并且我们可以运行它|接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法）|
|多继承|抽象方法可以继承一个类和实现多个接口|接口只可以继承一个或多个其它接口|
|速度|它比接口速度要快|接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。|
|添加新方法|如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。|如果你往接口中添加方法，那么你必须改变实现该接口的类。|
|成员变量|和普通Java类一样|默认是**public static final**修饰，必须初始化变量，且不能修改|
|静态代码|和普通Java类一样|不能有静态代码|

### 接口存在方法的实现

在java8以后，接口中可以添加使用default或者static修饰的方法，被修饰的方法视为普通方法，可以直接写方法体。例如：
```java
@FunctionalInterface
public interface Function<T, R> {
    ...
    static <T> Function<T, T> identity() {
        return t -> t;
    }
}
```
子类可以不重写接口中的static和default方法，不重写的情况下，默认调用的是接口的方法实现。